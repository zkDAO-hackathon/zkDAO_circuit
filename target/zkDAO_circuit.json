{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":699026489032531638,"abi":{"parameters":[{"name":"_proposalId","type":{"kind":"field"},"visibility":"public"},{"name":"_secret","type":{"kind":"field"},"visibility":"private"},{"name":"_voter","type":{"kind":"field"},"visibility":"private"},{"name":"_weight","type":{"kind":"field"},"visibility":"public"},{"name":"_choice","type":{"kind":"integer","sign":"signed","width":8},"visibility":"public"},{"name":"_snapshot_merkle_tree","type":{"kind":"field"},"visibility":"public"},{"name":"_leaf","type":{"kind":"field"},"visibility":"private"},{"name":"_index","type":{"kind":"field"},"visibility":"private"},{"name":"_path","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"},{"name":"_pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"_pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"_signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"_hashed_message","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"7099575933129415963":{"error_kind":"string","string":"Mismatch hashes"},"14367162763363126606":{"error_kind":"string","string":"Choice out of range"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/9T9ebxuR1rWje+GI5zACZxAAgkkkEACCSRQ86oFCaQ1rWlNa1rTGjRoatVg0EYbbbXVVltttdVWWxkEREVFRV/neZ7neUBFRT3OqKioqKiov++9G97PU5v9+2vd6/082el0knX2fnbVqrqv+7quu4Y3XHzw68M/8uLib3/oB//9Dfz9od/5zxv8ffPKs4+85tmta57dfc2zj7rm2Udf8+z2Nc/uuebZx1zz7GOveXbvNc/uu+bZx13z7OOveXb/Nc8euObZJ1zz7BOvefbgNc8euubZJ13z7JOvefbwNc8euebZp1zz7FOvefboNc8eu+bZp13z7NOvefb4Nc+euObZZ1zz7DOvefbkNc+euubZZ13z7LOveWaueWaveeaueeaveRaueRaveZauebZc8yxf82y95tnnXPPsc6959vQ1z5655tnnXfPs86959uw1z954zbPvec2z73XNs+euefama55972uefZ9rnj1/zbM3X/Ps+17z7Ptd8+yFa5695Zpn3/+aZz/gmmcvXvPsrdc8+4HXPPtB1zx76Zpnb7vm2Q++5tkPuebZy9c8+4Jrnv3Qa579sGuevXLNsy+85tkPv+bZj7jm2avXPCvXPNuueVavedauedaveTauefYjr3n22jXPvuiaZz/qmmc/+ppnb7/m2Rdf8+zHXPPsx17z7B3XPPuSa579uGue/fhrnr3zmmc/4ZpnP/GaZz/pmmfvuubZT77m2U+55tlPvebZu6959tOuefbTr3n2M6559p5rnv3Ma579rGue/exrnr33mmc/55pnP/eaZz/vmmfvu+bZz7/m2S+45tkvvObZ+6959ouuefaLr3n2S6559oFrnv3Sa579smuefek1z77smmdffs2zr7jm2S+/5tlXXvPsq6559tXXPPsV1zz7mmue/cprnv2qa5796muefe01z37NNc9+7TXPft01z77umme//ppnv+GaZ7/xmmdff82z33TNs9/8nc8uvvO/5evZ7/yn2fdl3/Cdn/khVz/XdpdzCWnrwa02b97UzXTX/Mh+WTdrRrK2rMVY0+zWS3NtjJ6tK62Zmt9w8lnepBD64rr1thi3bjmaELeUbbYxx+ay9z2HzMeui1lt8N2OuPrxnY38LSefZXuwjb8WW+0Wl7E6G1trW3W+u6UuoeRao6nd52q9N2uhNWMb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","debug_symbols":"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","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"use crate::runtime::is_unconstrained;\n\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[foreign(keccakf1600)]\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n\n#[no_predicates]\n#[deprecated(\"keccak256 is being deprecated from the stdlib, use https://github.com/noir-lang/keccak256 instead\")]\npub(crate) fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\n    assert(N >= message_size);\n\n    // Copy input to block bytes. For that we'll need at least input bytes (N)\n    // but we want it to be padded to a multiple of BLOCK_SIZE_IN_BYTES.\n    let mut block_bytes = [0; ((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES];\n    if is_unconstrained() {\n        for i in 0..message_size {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < message_size {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    //1. format_input_lanes\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    //maximum number of bytes to hash\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[message_size] = 1;\n    block_bytes[real_blocks_bytes - 1] = 0x80;\n\n    // populate a vector of 64-bit limbs from our byte array\n    let mut sliced_buffer =\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\n    for i in 0..sliced_buffer.len() {\n        let limb_start = WORD_SIZE * i;\n\n        let mut sliced = 0;\n        let mut v = 1;\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer[i] = sliced as u64;\n    }\n\n    //2. sponge_absorb\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n    // When in an unconstrained runtime we can take advantage of runtime loop bounds,\n    // thus allowing us to simplify the loop body.\n    if is_unconstrained() {\n        for i in 0..real_max_blocks {\n            if (i == 0) {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = sliced_buffer[j];\n                }\n            } else {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n            }\n            state = keccakf1600(state);\n        }\n    } else {\n        // `real_max_blocks` is guaranteed to at least be `1`\n        // We peel out the first block as to avoid a conditional inside of the loop.\n        // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\n        for j in 0..LIMBS_PER_BLOCK {\n            state[j] = sliced_buffer[j];\n        }\n        state = keccakf1600(state);\n        for i in 1..max_blocks {\n            if i < real_max_blocks {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n                state = keccakf1600(state);\n            }\n        }\n    }\n\n    //3. sponge_squeeze\n    let mut result = [0; 32];\n    for i in 0..4 {\n        let lane = state[i] as Field;\n        let lane_le: [u8; 8] = lane.to_le_bytes();\n        for j in 0..8 {\n            result[8 * i + j] = lane_le[j];\n        }\n    }\n    result\n}\n\nmod tests {\n    use super::keccak256;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x5a, 0x50, 0x2f, 0x9f, 0xca, 0x46, 0x7b, 0x26, 0x6d, 0x5b, 0x78, 0x33, 0x65, 0x19,\n            0x37, 0xe8, 0x05, 0x27, 0x0c, 0xa3, 0xf3, 0xaf, 0x1c, 0x0d, 0xd2, 0x46, 0x2d, 0xca,\n            0x4b, 0x3b, 0x1a, 0xbf,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n\n    #[test]\n    fn hash_hello_world() {\n        let input = \"Hello world!\".as_bytes();\n        let result = [\n            0xec, 0xd0, 0xe1, 0x8, 0xa9, 0x8e, 0x19, 0x2a, 0xf1, 0xd2, 0xc2, 0x50, 0x55, 0xf4, 0xe3,\n            0xbe, 0xd7, 0x84, 0xb5, 0xc8, 0x77, 0x20, 0x4e, 0x73, 0x21, 0x9a, 0x52, 0x3, 0x25, 0x1f,\n            0xea, 0xab,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n\n    #[test]\n    fn var_size_hash() {\n        let input = [\n            189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205,\n            206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222,\n            223,\n        ];\n        let result = [\n            226, 37, 115, 94, 94, 196, 72, 116, 194, 105, 79, 233, 65, 12, 30, 94, 181, 131, 170,\n            219, 171, 166, 236, 88, 143, 67, 255, 160, 248, 214, 39, 129,\n        ];\n        assert_eq(keccak256(input, 13), result);\n    }\n\n    #[test]\n    fn hash_longer_than_136_bytes() {\n        let input = \"123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789\"\n            .as_bytes();\n        assert(input.len() > 136);\n\n        let result = [\n            0x1d, 0xca, 0xeb, 0xdf, 0xd9, 0xd6, 0x24, 0x67, 0x1c, 0x18, 0x16, 0xda, 0xd, 0x8a, 0xeb,\n            0xa8, 0x75, 0x71, 0x2c, 0xc, 0x89, 0xe0, 0x25, 0x2, 0xe8, 0xb6, 0x5e, 0x16, 0x5, 0x55,\n            0xe4, 0x40,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n}\n","path":"std/hash/keccak.nr"},"20":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"22":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::hash::poseidon::bn254::consts;\nuse crate::hash::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"std/hash/poseidon/bn254/perm.nr"},"23":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::hash::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"std/hash/poseidon/bn254.nr"},"24":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse crate::default::Default;\nuse crate::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        crate::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        crate::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    crate::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: Field,\n    capacity: Field,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, rate + capacity);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n\nmod poseidon_tests {\n    use crate::hash::poseidon;\n\n    #[test]\n    fn reference_impl_test_vectors() {\n        // hardcoded test vectors from https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/test_vectors.txt\n        {\n            let mut state = [0, 1, 2];\n            let mut expected = [\n                0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a,\n                0x0fca49b798923ab0239de1c9e7a4a9a2210312b6a2f616d18b5a87f9b628ae29,\n                0x0e7ae82e40091e63cbd4f16a6d16310b3729d4b6e138fcf54110e2867045a30c,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_3(state),\n                \"Failed to reproduce output for [0, 1, 2]\",\n            );\n        }\n        {\n            let mut state = [0, 1, 2, 3, 4];\n            let mut expected = [\n                0x299c867db6c1fdd79dcefa40e4510b9837e60ebb1ce0663dbaa525df65250465,\n                0x1148aaef609aa338b27dafd89bb98862d8bb2b429aceac47d86206154ffe053d,\n                0x24febb87fed7462e23f6665ff9a0111f4044c38ee1672c1ac6b0637d34f24907,\n                0x0eb08f6d809668a981c186beaf6110060707059576406b248e5d9cf6e78b3d3e,\n                0x07748bc6877c9b82c8b98666ee9d0626ec7f5be4205f79ee8528ef1c4a376fc7,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_5(state),\n                \"Failed to reproduce output for [0, 1, 2, 3, 4]\",\n            );\n        }\n    }\n}\n","path":"std/hash/poseidon/mod.nr"},"31":{"source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\n#[deprecated(\"This function will be removed from the stdlib in version 1.0.0-beta.4\")]\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let index_bits: [u1; N] = index.to_le_bits();\n    let mut current = leaf;\n    for i in 0..N {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n","path":"std/merkle.nr"},"61":{"source":"use dep::ecrecover;\nuse std::hash::poseidon;\n\nfn main(\n    _proposalId: pub Field,\n    _secret: Field,\n    _voter: Field,\n    _weight: pub Field,\n    _choice: pub i8,\n\n    _snapshot_merkle_tree: pub Field,\n    _leaf: Field,\n    _index: Field,\n    _path: [Field; 3],\n\n    _pub_key_x: [u8; 32],\n    _pub_key_y: [u8; 32],\n    _signature: [u8; 64],\n    _hashed_message: [u8; 32],\n) -> pub Field { \n    let nullfier = poseidon::bn254::hash_2([_secret, _proposalId]);\n    let hash = poseidon::bn254::hash_3([_voter, _weight, nullfier]);\n    assert(hash == _leaf, \"Mismatch hashes\");    \n    assert(_choice <= 2, \"Choice out of range\");\n    assert(verify_merkle_tree(_snapshot_merkle_tree, _leaf, _index, _path));\n\n    let address = ecrecover::ecrecover(_pub_key_x, _pub_key_y, _signature, _hashed_message);\n    assert(address == _voter);\n\n    nullfier\n}\n\nfn verify_merkle_tree(\n    expected_root: Field,\n    leaf: Field,\n    index: Field,\n    path: [Field; 3]\n) -> bool {\n    let root = std::merkle::compute_merkle_root(leaf, index, path);\n    root == expected_root\n}\n\n/**\n    // these values are for this example only\n    fn compute_root_from_slice(leaf: Field, index: Field, path: [Field]) -> Field {\n        let mut hash = leaf;\n        let index_u32: u32 = index as u32;\n\n        for index in 0..path.len() {\n            let sibling = path[index];\n            let index_u8: u8 = index as u8;\n\n        if ((index_u32 >> index_u8) & 1) == 0 {\n                hash = poseidon::bn254::hash_2([hash, sibling]);\n            } else {\n                hash = poseidon::bn254::hash_2([sibling, hash]);\n            }\n        }\n\n        hash\n}\n*/\n\n","path":"/home/salviega/hackathons/chromion-chainlink-hackathon/zkDAO/zkDAO_circuit/src/main.nr"},"62":{"source":"mod secp256k1;\n\npub fn ecrecover(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64], // clip v value\n    hashed_message: [u8; 32]\n) -> Field {\n    let key = secp256k1::PubKey::from_xy(pub_key_x, pub_key_y);\n\n    assert(key.verify_sig(signature, hashed_message));\n    let addr = key.to_eth_address();\n\n    addr\n}\n\n#[test]\nfn test_ecrecover() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let addr = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/home/salviega/nargo/github.com/colinnielsen/ecrecover-noir/v0.30.0/src/lib.nr"},"63":{"source":"use dep::std;\nuse dep::array_helpers;\n\npub struct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    pub fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    pub fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    pub fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    pub fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    pub fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/home/salviega/nargo/github.com/colinnielsen/ecrecover-noir/v0.30.0/src/secp256k1.nr"}},"names":["main"],"brillig_names":["decompose_hint","directive_integer_quotient","directive_to_radix","directive_invert"]}