{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":1491568745269156840,"abi":{"parameters":[{"name":"_proposalId","type":{"kind":"field"},"visibility":"public"},{"name":"_secret","type":{"kind":"field"},"visibility":"private"},{"name":"_voter","type":{"kind":"field"},"visibility":"private"},{"name":"_weight","type":{"kind":"field"},"visibility":"public"},{"name":"_snapshot_merkle_tree","type":{"kind":"field"},"visibility":"public"},{"name":"_leaf","type":{"kind":"field"},"visibility":"private"},{"name":"_index","type":{"kind":"field"},"visibility":"private"},{"name":"_path","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"_pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"_pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"_signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"_hashed_message","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"7099575933129415963":{"error_kind":"string","string":"Mismatch hashes"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"use crate::runtime::is_unconstrained;\n\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[foreign(keccakf1600)]\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n\n#[no_predicates]\n#[deprecated(\"keccak256 is being deprecated from the stdlib, use https://github.com/noir-lang/keccak256 instead\")]\npub(crate) fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\n    assert(N >= message_size);\n\n    // Copy input to block bytes. For that we'll need at least input bytes (N)\n    // but we want it to be padded to a multiple of BLOCK_SIZE_IN_BYTES.\n    let mut block_bytes = [0; ((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES];\n    if is_unconstrained() {\n        for i in 0..message_size {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < message_size {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    //1. format_input_lanes\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    //maximum number of bytes to hash\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[message_size] = 1;\n    block_bytes[real_blocks_bytes - 1] = 0x80;\n\n    // populate a vector of 64-bit limbs from our byte array\n    let mut sliced_buffer =\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\n    for i in 0..sliced_buffer.len() {\n        let limb_start = WORD_SIZE * i;\n\n        let mut sliced = 0;\n        let mut v = 1;\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer[i] = sliced as u64;\n    }\n\n    //2. sponge_absorb\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n    // When in an unconstrained runtime we can take advantage of runtime loop bounds,\n    // thus allowing us to simplify the loop body.\n    if is_unconstrained() {\n        for i in 0..real_max_blocks {\n            if (i == 0) {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = sliced_buffer[j];\n                }\n            } else {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n            }\n            state = keccakf1600(state);\n        }\n    } else {\n        // `real_max_blocks` is guaranteed to at least be `1`\n        // We peel out the first block as to avoid a conditional inside of the loop.\n        // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\n        for j in 0..LIMBS_PER_BLOCK {\n            state[j] = sliced_buffer[j];\n        }\n        state = keccakf1600(state);\n        for i in 1..max_blocks {\n            if i < real_max_blocks {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n                state = keccakf1600(state);\n            }\n        }\n    }\n\n    //3. sponge_squeeze\n    let mut result = [0; 32];\n    for i in 0..4 {\n        let lane = state[i] as Field;\n        let lane_le: [u8; 8] = lane.to_le_bytes();\n        for j in 0..8 {\n            result[8 * i + j] = lane_le[j];\n        }\n    }\n    result\n}\n\nmod tests {\n    use super::keccak256;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x5a, 0x50, 0x2f, 0x9f, 0xca, 0x46, 0x7b, 0x26, 0x6d, 0x5b, 0x78, 0x33, 0x65, 0x19,\n            0x37, 0xe8, 0x05, 0x27, 0x0c, 0xa3, 0xf3, 0xaf, 0x1c, 0x0d, 0xd2, 0x46, 0x2d, 0xca,\n            0x4b, 0x3b, 0x1a, 0xbf,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n\n    #[test]\n    fn hash_hello_world() {\n        let input = \"Hello world!\".as_bytes();\n        let result = [\n            0xec, 0xd0, 0xe1, 0x8, 0xa9, 0x8e, 0x19, 0x2a, 0xf1, 0xd2, 0xc2, 0x50, 0x55, 0xf4, 0xe3,\n            0xbe, 0xd7, 0x84, 0xb5, 0xc8, 0x77, 0x20, 0x4e, 0x73, 0x21, 0x9a, 0x52, 0x3, 0x25, 0x1f,\n            0xea, 0xab,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n\n    #[test]\n    fn var_size_hash() {\n        let input = [\n            189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205,\n            206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222,\n            223,\n        ];\n        let result = [\n            226, 37, 115, 94, 94, 196, 72, 116, 194, 105, 79, 233, 65, 12, 30, 94, 181, 131, 170,\n            219, 171, 166, 236, 88, 143, 67, 255, 160, 248, 214, 39, 129,\n        ];\n        assert_eq(keccak256(input, 13), result);\n    }\n\n    #[test]\n    fn hash_longer_than_136_bytes() {\n        let input = \"123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789\"\n            .as_bytes();\n        assert(input.len() > 136);\n\n        let result = [\n            0x1d, 0xca, 0xeb, 0xdf, 0xd9, 0xd6, 0x24, 0x67, 0x1c, 0x18, 0x16, 0xda, 0xd, 0x8a, 0xeb,\n            0xa8, 0x75, 0x71, 0x2c, 0xc, 0x89, 0xe0, 0x25, 0x2, 0xe8, 0xb6, 0x5e, 0x16, 0x5, 0x55,\n            0xe4, 0x40,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n}\n","path":"std/hash/keccak.nr"},"20":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"22":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::hash::poseidon::bn254::consts;\nuse crate::hash::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"std/hash/poseidon/bn254/perm.nr"},"23":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::hash::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"std/hash/poseidon/bn254.nr"},"24":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse crate::default::Default;\nuse crate::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        crate::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        crate::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    crate::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: Field,\n    capacity: Field,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, rate + capacity);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n\nmod poseidon_tests {\n    use crate::hash::poseidon;\n\n    #[test]\n    fn reference_impl_test_vectors() {\n        // hardcoded test vectors from https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/test_vectors.txt\n        {\n            let mut state = [0, 1, 2];\n            let mut expected = [\n                0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a,\n                0x0fca49b798923ab0239de1c9e7a4a9a2210312b6a2f616d18b5a87f9b628ae29,\n                0x0e7ae82e40091e63cbd4f16a6d16310b3729d4b6e138fcf54110e2867045a30c,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_3(state),\n                \"Failed to reproduce output for [0, 1, 2]\",\n            );\n        }\n        {\n            let mut state = [0, 1, 2, 3, 4];\n            let mut expected = [\n                0x299c867db6c1fdd79dcefa40e4510b9837e60ebb1ce0663dbaa525df65250465,\n                0x1148aaef609aa338b27dafd89bb98862d8bb2b429aceac47d86206154ffe053d,\n                0x24febb87fed7462e23f6665ff9a0111f4044c38ee1672c1ac6b0637d34f24907,\n                0x0eb08f6d809668a981c186beaf6110060707059576406b248e5d9cf6e78b3d3e,\n                0x07748bc6877c9b82c8b98666ee9d0626ec7f5be4205f79ee8528ef1c4a376fc7,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_5(state),\n                \"Failed to reproduce output for [0, 1, 2, 3, 4]\",\n            );\n        }\n    }\n}\n","path":"std/hash/poseidon/mod.nr"},"31":{"source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\n#[deprecated(\"This function will be removed from the stdlib in version 1.0.0-beta.4\")]\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let index_bits: [u1; N] = index.to_le_bits();\n    let mut current = leaf;\n    for i in 0..N {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n","path":"std/merkle.nr"},"61":{"source":"use dep::ecrecover;\nuse std::hash::poseidon;\n\nfn main(\n    _proposalId: pub Field,\n    _secret: Field,\n    _voter: Field,\n    _weight: pub Field,\n\n    _snapshot_merkle_tree: pub Field,\n    _leaf: Field,\n    _index: Field,\n    _path: [Field; 2],\n\n    _pub_key_x: [u8; 32],\n    _pub_key_y: [u8; 32],\n    _signature: [u8; 64],\n    _hashed_message: [u8; 32],\n) -> pub Field {\n    let nullifier = poseidon::bn254::hash_2([_secret, _proposalId]);\n\n    let hash = poseidon::bn254::hash_3([_voter, _weight, nullifier]);\n    assert(hash == _leaf, \"Mismatch hashes\");\n\n    assert(verify_merkle_tree(_snapshot_merkle_tree, _leaf, _index, _path));\n\n    let address = ecrecover::ecrecover(_pub_key_x, _pub_key_y, _signature, _hashed_message);\n    assert(address == _voter);\n\n    nullifier\n}\n\nfn verify_merkle_tree(\n    expected_root: Field,\n    leaf: Field,\n    index: Field,\n    path: [Field; 2]\n) -> bool {\n    let root = std::merkle::compute_merkle_root(leaf, index, path);\n    root == expected_root\n}\n\n/**\n    // these values are for this example only\n    fn compute_root_from_slice(leaf: Field, index: Field, path: [Field]) -> Field {\n        let mut hash = leaf;\n        let index_u32: u32 = index as u32;\n\n        for index in 0..path.len() {\n            let sibling = path[index];\n            let index_u8: u8 = index as u8;\n\n        if ((index_u32 >> index_u8) & 1) == 0 {\n                hash = poseidon::bn254::hash_2([hash, sibling]);\n            } else {\n                hash = poseidon::bn254::hash_2([sibling, hash]);\n            }\n        }\n\n        hash\n}\n*/\n\n","path":"/home/salviega/hackathons/chromion-chainlink-hackathon/zkDAO/zkDAO_circuit/src/main.nr"},"62":{"source":"mod secp256k1;\n\npub fn ecrecover(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64], // clip v value\n    hashed_message: [u8; 32]\n) -> Field {\n    let key = secp256k1::PubKey::from_xy(pub_key_x, pub_key_y);\n\n    assert(key.verify_sig(signature, hashed_message));\n    let addr = key.to_eth_address();\n\n    addr\n}\n\n#[test]\nfn test_ecrecover() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let addr = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/home/salviega/nargo/github.com/colinnielsen/ecrecover-noir/v0.30.0/src/lib.nr"},"63":{"source":"use dep::std;\nuse dep::array_helpers;\n\npub struct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    pub fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    pub fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    pub fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    pub fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    pub fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/home/salviega/nargo/github.com/colinnielsen/ecrecover-noir/v0.30.0/src/secp256k1.nr"}},"names":["main"],"brillig_names":["decompose_hint","directive_to_radix","directive_integer_quotient","directive_invert"]}